using Moq;
using Moq.Protected;
using System.Diagnostics;
using System.Net;

namespace DonkeyWork.Dev.SimpleRateLimiter.Tests
{
    public class SimpleRateLimitHandlerTests
    {
        /// <summary>
        /// Ensure the middleware throws an exception if provided an incorrect rate limit.
        /// </summary>
        [Fact]
        public void CreateHandler_WithInvalidInput_ThrowsException()
        {
            // Arrange
            var testHandler = new Mock<DelegatingHandler>();

            // Act + Assert
            Assert.Throws<ArgumentException>(() => CreateClient(testHandler, 0));
        }
        /// <summary>
        /// Create a <see cref="HttpClient"/> with our middleware and ensure the message is not impeded in any way.
        /// </summary>
        /// <param name="httpStatusCode">The desired status code response.</param>
        [Theory]
        [InlineData(HttpStatusCode.OK)]
        [InlineData(HttpStatusCode.Accepted)]
        [InlineData(HttpStatusCode.Created)]
        [InlineData(HttpStatusCode.BadGateway)]
        [InlineData(HttpStatusCode.BadRequest)]
        [InlineData(HttpStatusCode.TooManyRequests)]
        public async Task SendAsync_WithOneMessage_Succeeds(HttpStatusCode httpStatusCode)
        {
            // Arrange
            var httpRequest = new HttpRequestMessage(HttpMethod.Get, "/example");
            var testHandler = new Mock<DelegatingHandler>();
            var mockedResult = new HttpResponseMessage(httpStatusCode);

            void AssertThatRequestCorrect(HttpRequestMessage request, CancellationToken token)
            {
                Assert.Equal(request, httpRequest);
            }

            testHandler
                .Protected()
                .Setup<Task<HttpResponseMessage>>("SendAsync", httpRequest, ItExpr.IsAny<CancellationToken>())
                .Callback(
                    (Action<HttpRequestMessage, CancellationToken>)AssertThatRequestCorrect)
                .ReturnsAsync(mockedResult);

            var httpClient = CreateClient(testHandler);

            // Act
            var actualResponse = await httpClient.SendAsync(httpRequest);

            // Assert
            testHandler
                .Protected()
                .Verify("SendAsync", Times.Once(), httpRequest, ItExpr.IsAny<CancellationToken>());

            Assert.Equal(actualResponse.StatusCode, httpStatusCode);
            Assert.Equal(actualResponse, mockedResult);
            Mock.VerifyAll();
        }

        /// <summary>
        /// Ensures that an exception generated by the <see cref="HttpClient.SendAsync(HttpRequestMessage)"/> is passed up the stack.
        /// </summary>
        /// <returns>a Task.</returns>
        [Fact]
        public async Task SendAsync_WithException_ThrowsException()
        {
            //Arrange
            var httpRequest = new HttpRequestMessage(HttpMethod.Get, "/example");
            var testHandler = new Mock<DelegatingHandler>();

            testHandler
                .Protected()
                .Setup<Task<HttpResponseMessage>>("SendAsync", httpRequest, ItExpr.IsAny<CancellationToken>())
                .ThrowsAsync(new System.ArgumentNullException());

            var httpClient = CreateClient(testHandler);

            // Act + Assert
            await Assert.ThrowsAsync<System.ArgumentNullException>(async () => await httpClient.SendAsync(httpRequest));
        }
        
        /// <summary>
        /// Send Multiple requests to the RateLimiter and ensure that messages are delayed / limited as expected.
        /// </summary>
        /// <param name="requestsPerSecond">The desired requests per second restrictions.</param>
        /// <param name="maxRequests">The total number of requests to send.</param>
        [Theory]
        [InlineData(1, 1)]
        [InlineData(2, 10)]
        [InlineData(4, 20)]
        [InlineData(5, 25)]
        [InlineData(10, 100)]        
        [InlineData(25, 100)]
        [InlineData(75, 200)]
        public async Task SendAsync_WithMultipleMessages_PerformsRateLimiting(int requestsPerSecond, int maxRequests)
        {
            // Arrange
            var testHandler = new Mock<DelegatingHandler>();
            var mockedResult = new HttpResponseMessage(HttpStatusCode.Accepted);
            
            testHandler
                .Protected()
                .Setup<Task<HttpResponseMessage>>("SendAsync", ItExpr.IsAny<HttpRequestMessage>(), ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(mockedResult);

            var httpClient = CreateClient(testHandler, requestsPerSecond);

            // Act
            Stopwatch stopWatch = Stopwatch.StartNew();
            foreach (var _ in Enumerable.Range(0, maxRequests))
            {
                using var httpRequest = new HttpRequestMessage(HttpMethod.Get, "/example");
                var actualResponse = await httpClient.SendAsync(httpRequest);

                Assert.Equal(HttpStatusCode.Accepted, actualResponse.StatusCode);
                Assert.Equal(actualResponse, mockedResult);
            }
            stopWatch.Stop();
            
            // Assert
            Assert.True((stopWatch.ElapsedMilliseconds / 1000) >= (maxRequests / requestsPerSecond) - 1);
            testHandler
                .Protected()
                .Verify("SendAsync", Times.Exactly(maxRequests), ItExpr.IsAny<HttpRequestMessage>(), ItExpr.IsAny<CancellationToken>());
        }

        /// <summary>
        /// Create a mocked HTTPClient with the desired middleware.
        /// </summary>
        /// <param name="testHandler">The test handler.</param>
        /// <param name="maxRequestsPerSecond">The desired RateLimit.</param>
        /// <returns></returns>
        private static HttpClient CreateClient(Mock<DelegatingHandler> testHandler, int maxRequestsPerSecond = 10)
        {
            var subject = new SimpleRateLimitHandler(maxRequestsPerSecond)
            {
                InnerHandler = testHandler.Object
            };

            return new HttpClient(subject)
            {
                BaseAddress = new Uri("https://localhost")
            };
        }
    }
}